use std::{
    collections::BTreeSet,
    convert::Infallible,
    env,
    ffi::OsStr,
    fmt::Write as _,
    fs,
    fs::OpenOptions,
    io::Write as _,
    path::{Path, PathBuf},
};

use anyhow::Context;
use heck::ToShoutySnakeCase;
use pico_args::Arguments;
use proc_macro2::TokenStream;
use quote::quote;
use static_lang_word_lists::WordListMetadata;
use walkdir::{DirEntry, WalkDir};

pub fn main(mut args: Arguments) -> anyhow::Result<()> {
    let workspace_root = env::var_os("CARGO_MANIFEST_DIR")
        .map(PathBuf::from)
        .expect("xtask run without Cargo")
        .parent()
        .unwrap()
        .to_owned();
    let slwl_build_script_path = args
        .opt_value_from_os_str(["-o", "--output"], |arg| {
            Ok::<_, Infallible>(PathBuf::from(arg))
        })
        .unwrap()
        .unwrap_or_else(|| {
            workspace_root.join("static-lang-word-lists/chicken.rs")
        });
    let mut slwl_build = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(&slwl_build_script_path)
        .context("failed to open output file")?;

    let data_dir = workspace_root.join("static-lang-word-lists/data");
    let metadatas = WalkDir::new(&data_dir)
        .into_iter()
        .filter_map(|de_res| {
            match de_res {
                Ok(entry) if is_metadata_toml(&entry) => {
                    Some(entry.into_path())
                },
                // Irrelevant stuff
                Ok(_) => None,
                Err(why) => {
                    eprintln!(
                        "failed to explore part of \
                         static-lang-word-lists/data: {why}"
                    );
                    None
                },
            }
        })
        .map(
            |metadata_toml| -> anyhow::Result<(PathBuf, WordListMetadata)> {
                let bytes = fs::read(&metadata_toml)
                    .context("failed to read metadata")?;
                let metadata = toml::from_slice(&bytes)
                    .context("failed to parse metadata")?;
                Ok((metadata_toml, metadata))
            },
        )
        .collect::<anyhow::Result<Vec<_>>>()?;

    let mut all_features = BTreeSet::new();
    let chicken_entries = metadatas.iter().map(|(toml_path, metadata)| {
        let word_list_path = toml_path.with_extension("txt");

        let WordListMetadata {
            name,
            language,
            script,
        } = metadata;
        let ident = name.to_shouty_snake_case();
        let path = word_list_path
            .strip_prefix(&data_dir)
            .unwrap()
            .to_str()
            .expect("word list with non UTF-8 relative path")
            .replace("\\", "/");
        let script = match script {
            Some(script) => {
                quote! { Some(std::borrow::Cow::Borrowed(#script)) }
            },
            None => quote! { None },
        };
        let language = match language {
            Some(language) => {
                quote! { Some(std::borrow::Cow::Borrowed(#language)) }
            },
            None => quote! { None },
        };
        let features = get_features_for_word_list(&word_list_path, metadata);
        all_features.extend(features.clone());
        let features = features_to_attribute(&features);
        quote! {
            // See start of output token stream below for struct definition
            WordListDecl {
                name: #name,
                ident: #ident,
                rel_path: #path,
                metadata_decl: ::std::stringify!(crate::WordListMetadata {
                    name: std::borrow::Cow::Borrowed(#name),
                    script: #script,
                    language: #language,
                }),
                features_attr: ::std::stringify!(#features),
            }
        }
    });

    let output = quote! {
        #[derive(Debug, Copy, Clone)]
        struct WordListDecl {
            name: &'static str,
            ident: &'static str,
            rel_path: &'static str,
            metadata_decl: &'static str,
            features_attr: &'static str,
        }

        static WORD_LISTS: &[WordListDecl] = &[
            #(#chicken_entries),*
        ];
    };
    let syntax_tree =
        syn::parse2(output).context("failed to parse TokenStream with syn")?;
    let formatted = prettyplease::unparse(&syntax_tree);

    // TODO: is a #[rustfmt::skip] in the generated file necessary?
    #[rustfmt::skip]
    writeln!(
        &mut slwl_build,
        "// @generated by cargo xtask egg\n\
        {formatted}",
    )?;

    eprintln!(
        "wrote to {}",
        slwl_build_script_path
            .strip_prefix(workspace_root)
            .unwrap_or(&slwl_build_script_path)
            .display()
    );
    eprintln!(
        "make sure crate features are added in \
         static-lang-word-lists/Cargo.toml"
    );
    println!("{}", format_all_features(&all_features));

    Ok(())
}

fn is_metadata_toml(entry: &DirEntry) -> bool {
    entry.file_type().is_file()
        && entry.path().extension() == Some(OsStr::new("toml"))
}

fn get_features_for_word_list(
    path: &Path,
    metadata: &WordListMetadata,
) -> Vec<String> {
    let mut features = Vec::with_capacity(1);

    let source = path
        .parent()
        .unwrap()
        .file_name()
        .unwrap()
        .to_str()
        .expect("parent dir of word list wasn't UTF-8")
        .to_ascii_lowercase();
    features.push(source);

    if let Some(script) = metadata.script.as_ref() {
        features.push(format!("script-{}", script.to_ascii_lowercase()));
    }

    if let Some(language) = metadata.language.as_ref() {
        features.push(format!("lang-{}", language.to_ascii_lowercase()));
    }

    features
}

fn features_to_attribute(
    features: impl IntoIterator<Item = impl quote::ToTokens>,
) -> TokenStream {
    let features_iter = features.into_iter();
    quote! { #[cfg(any(#( feature = #features_iter, )* ))]}
}

fn format_all_features(
    all_features: impl IntoIterator<Item = impl AsRef<str>>,
) -> String {
    let mut buf = String::from(
        "[features]\ndefault = [\"diffenator\"]\nrayon = [\"dep:rayon\"]\n",
    );
    all_features.into_iter().for_each(|feature| {
        writeln!(&mut buf, "{} = []", feature.as_ref()).unwrap();
    });
    buf
}
