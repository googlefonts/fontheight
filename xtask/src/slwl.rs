use std::{
    collections::BTreeSet, fmt::Write as _, fs::OpenOptions, io::Write as _,
    path::Path,
};

use anyhow::Context;
use heck::ToShoutySnakeCase;
use pico_args::Arguments;
use quote::{format_ident, quote};

use crate::{
    WordListMetadata, format_tokens, load_all_metadata, workspace_root,
};

pub fn main(mut args: Arguments) -> anyhow::Result<()> {
    let workspace_root = workspace_root();
    let slwl_declarations_path =
        workspace_root.join("static-lang-word-lists/src/declarations.rs");
    let mut slwl_declarations = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(&slwl_declarations_path)
        .context("failed to open static-lang-word-lists/src/declarations.rs")?;
    let slwl_chicken_path =
        workspace_root.join("static-lang-word-lists/chicken.rs");
    let mut slwl_chicken = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(&slwl_chicken_path)
        .context("failed to open static-lang-word-lists/chicken.rs")?;

    let data_dir = workspace_root.join("static-lang-word-lists/data");

    let metadatas = load_all_metadata()?;
    let mut chicken_entries = Vec::with_capacity(metadatas.len());
    let mut all_features = BTreeSet::new();
    let mut word_list_entries = Vec::with_capacity(metadatas.len());
    let mut all_word_lists_entries = Vec::with_capacity(metadatas.len());

    metadatas.iter().for_each(|(toml_path, metadata)| {
        let word_list_path = toml_path.with_extension("txt");

        let WordListMetadata {
            name,
            language,
            script,
        } = metadata;
        let ident = format_ident!("{}", name.to_shouty_snake_case());
        let path = word_list_path
            .strip_prefix(&data_dir)
            .unwrap()
            .to_str()
            .expect("word list with non UTF-8 relative path")
            .replace("\\", "/");
        let script = match script {
            Some(script) => quote! { Some(#script) },
            None => quote! { None },
        };
        let language = match language {
            Some(language) => quote! { Some(#language) },
            None => quote! { None },
        };
        let feature_list =
            get_features_for_word_list(&word_list_path, metadata);
        all_features.extend(feature_list.clone());
        // This is now an expectation as every word list should have a source,
        // and be part of "all"
        debug_assert!(feature_list.len() > 1);
        let feature_cfg_attr_inner = quote! {
            any(#( feature = #feature_list, )* )
        };

        chicken_entries.push(quote! { #[cfg(#feature_cfg_attr_inner)] #path });

        all_word_lists_entries.push(quote! {
            #[cfg(#feature_cfg_attr_inner)] &#ident,
        });

        word_list_entries.push(quote! {
            // Not docsrs and a relevant feature
            #[cfg(all(not(docsrs), #feature_cfg_attr_inner))]
            word_list! {
                ident: #ident,
                metadata: crate::WordListMetadata::new(#name, #script, #language),
                bytes: ::std::include_bytes!(
                    ::std::concat!(::std::env!("OUT_DIR"), '/', #path, ".br")
                ),
            }
            // Is docs.rs + relevant feature
            #[cfg(all(docsrs, #feature_cfg_attr_inner))]
            #[doc = "The "]
            #[doc = ::std::stringify!(#ident)]
            #[doc = " word list.\n\nCompiled into the binary compressed with Brotli, decompressed at runtime."]
            pub static #ident: crate::WordList = crate::WordList::stub();
        });
    });

    let chicken = quote! {
        static WORD_LISTS: &[&str] = &[
            #(#chicken_entries),*
        ];
    };
    write!(
        &mut slwl_chicken,
        "// @generated by cargo xtask slwl\n{}",
        format_tokens(chicken)?,
    )
    .context("failed to write to static-lang-word-lists/chicken.rs")?;

    let declarations = quote! {
        #(#word_list_entries)*

        #[doc = "All the available [`WordList`](crate::WordList)s"]
        pub static ALL_WORD_LISTS: &[&crate::WordList] = &[
            #(#all_word_lists_entries)*
        ];
    };
    write!(
        &mut slwl_declarations,
        "// @generated by cargo xtask slwl\n{}",
        format_tokens(declarations)?,
    )
    .context("failed to write to static-lang-word-lists/src/declarations.rs")?;

    eprintln!(
        "wrote to static-lang-word-lists/chicken.rs & \
         static-lang-word-lists/src/declarations.rs"
    );
    if !args.contains(["-q", "--no-emit-features"]) {
        eprintln!(
            "make sure crate features are added in \
             static-lang-word-lists/Cargo.toml"
        );
        println!("{}", format_all_features(&all_features));
    }

    Ok(())
}

pub fn get_features_for_word_list(
    path: &Path,
    metadata: &WordListMetadata,
) -> Vec<String> {
    let mut features = vec![String::from("all")];

    let source = path
        .parent()
        .unwrap()
        .file_name()
        .unwrap()
        .to_str()
        .expect("parent dir of word list wasn't UTF-8")
        .to_ascii_lowercase();
    features.push(source);

    if let Some(script) = metadata.script.as_ref() {
        features.push(format!("script-{}", script.to_ascii_lowercase()));
    }

    if let Some(language) = metadata.language.as_ref() {
        features.push(format!("lang-{}", language.to_ascii_lowercase()));
    }

    features
}

fn format_all_features(
    all_features: impl IntoIterator<Item = impl AsRef<str>>,
) -> String {
    let mut buf = String::from(
        "[features]\ndefault = [\"diffenator\"]\nrayon = [\"dep:rayon\"]\n",
    );
    all_features.into_iter().for_each(|feature| {
        writeln!(&mut buf, "{} = []", feature.as_ref()).unwrap();
    });
    buf
}
