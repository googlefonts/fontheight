use std::{
    collections::BTreeSet, fmt::Write as _, fs::OpenOptions, io::Write as _,
    path::Path,
};

use anyhow::Context;
use heck::ToShoutySnakeCase;
use pico_args::Arguments;
use quote::{format_ident, quote};

use crate::{
    WordListMetadata, format_tokens, load_all_metadata, workspace_root,
};

pub fn main(_args: Arguments) -> anyhow::Result<()> {
    let workspace_root = workspace_root();
    let slwl_declarations_path =
        workspace_root.join("static-lang-word-lists/src/declarations.rs");
    let mut slwl_declarations = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(&slwl_declarations_path)
        .context("failed to open static-lang-word-lists/src/declarations.rs")?;
    let slwl_chicken_path =
        workspace_root.join("static-lang-word-lists/chicken.rs");
    let mut slwl_chicken = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(&slwl_chicken_path)
        .context("failed to open static-lang-word-lists/chicken.rs")?;

    let data_dir = workspace_root.join("static-lang-word-lists/data");

    let metadatas = load_all_metadata()?;
    let mut chicken_entries = Vec::with_capacity(metadatas.len());
    let mut all_features = BTreeSet::new();
    let mut word_list_entries = Vec::with_capacity(metadatas.len());
    let mut lookup_table_entries = Vec::with_capacity(metadatas.len());

    metadatas.iter().for_each(|(toml_path, metadata)| {
        let word_list_path = toml_path.with_extension("txt");

        let WordListMetadata {
            name,
            language,
            script,
        } = metadata;
        let ident = format_ident!("{}", name.to_shouty_snake_case());
        let path = word_list_path
            .strip_prefix(&data_dir)
            .unwrap()
            .to_str()
            .expect("word list with non UTF-8 relative path")
            .replace("\\", "/");
        let script = match script {
            Some(script) => quote! { Some(#script) },
            None => quote! { None },
        };
        let language = match language {
            Some(language) => quote! { Some(#language) },
            None => quote! { None },
        };
        let feature_list =
            get_features_for_word_list(&word_list_path, metadata);
        all_features.extend(feature_list.clone());
        let feature_gate = quote! { #[cfg(any(#( feature = #feature_list, )* ))]};

        chicken_entries.push(quote! { #feature_gate #path });

        lookup_table_entries.push(quote! {
            #feature_gate
            #name => #ident,
        });

        word_list_entries.push(quote! {
            // Not docsrs and a relevant feature
            #[cfg(all(not(docsrs), any(#( feature = #feature_list, )* )))]
            word_list! {
                ident: #ident,
                metadata: crate::WordListMetadata::new(#name, #script, #language),
                bytes: ::std::include_bytes!(
                    ::std::concat!(::std::env!("OUT_DIR"), '/', #path, ".br")
                ),
            }
            // Is docs.rs + relevant feature
            #[cfg(all(docsrs, any(#( feature = #feature_list, )* )))]
            #[doc = "The "]
            #[doc = ::std::stringify!(#ident)]
            #[doc = "word list.\n\nCompiled into the binary compressed with Brotli, decompressed at runtime."]
            pub static #ident: crate::WordList = crate::WordList::stub();
        });
    });

    let chicken = quote! {
         #[rustfmt::skip]
        static WORD_LISTS: &[&str] = &[
            #(#chicken_entries),*
        ];
    };
    write!(
        &mut slwl_chicken,
        "// @generated by cargo xtask slwl\n{}",
        format_tokens(chicken)?,
    )?;

    let declarations = quote! {
        #(#word_list_entries)*

        // TODO: https://github.com/rust-phf/rust-phf/issues/356
        #[doc = "A lookup map for the crate-provided [`WordList`]s. Maps their names to the corresponding static [`WordList`]."]
        pub static LOOKUP_TABLE: ::phf::Map<&'static str, &'static crate::WordList> =
            ::phf::phf_map! {
        //         #(#lookup_table_entries)*
            };
    };
    write!(
        &mut slwl_declarations,
        "// @generated by cargo xtask slwl\n{}",
        format_tokens(declarations)?,
    )?;

    eprintln!(
        "wrote to static-lang-word-lists/chicken.rs & \
         static-lang-word-lists/src/declarations.rs"
    );
    eprintln!(
        "make sure crate features are added in \
         static-lang-word-lists/Cargo.toml"
    );
    println!("{}", format_all_features(&all_features));

    Ok(())
}

pub fn get_features_for_word_list(
    path: &Path,
    metadata: &WordListMetadata,
) -> Vec<String> {
    let mut features = Vec::with_capacity(1);

    let source = path
        .parent()
        .unwrap()
        .file_name()
        .unwrap()
        .to_str()
        .expect("parent dir of word list wasn't UTF-8")
        .to_ascii_lowercase();
    features.push(source);

    if let Some(script) = metadata.script.as_ref() {
        features.push(format!("script-{}", script.to_ascii_lowercase()));
    }

    if let Some(language) = metadata.language.as_ref() {
        features.push(format!("lang-{}", language.to_ascii_lowercase()));
    }

    features
}

fn format_all_features(
    all_features: impl IntoIterator<Item = impl AsRef<str>>,
) -> String {
    let mut buf = String::from(
        "[features]\ndefault = [\"diffenator\"]\nrayon = [\"dep:rayon\"]\n",
    );
    all_features.into_iter().for_each(|feature| {
        writeln!(&mut buf, "{} = []", feature.as_ref()).unwrap();
    });
    buf
}
